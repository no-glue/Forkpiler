# Assignment 1
I have included two test cases which pass and 7 test cases which fail. 

## Passing Test Cases
The test cases which pass are built to test two things. The first test case which passes, pass1.alan, tests how the recursive descent parsing works. It included nested {}s and a longer integer expression that includes addition and subtraction. This shows how the code correctly handles the tail recursive rewrite rules. It also does not include a $ at the end however it still passes lex with only a warning. As of writing this the compiler does not care about the $ in the sense that nothing actually every checks for it’s existence outside of lex as it is seemingly unnecessary in parse and moving forward. A warning will however be generated in order to conform to the specs of the language.The second test case, pass2.alan, passes with simpler less recursive calls however it does include a $. One thing to note with the second test case is that it correctly parses P(a) as printing an id. Even though it is not specified in the spec the lex lexes print as also being a print operator. This is because I found simply a P to be very uninformative. It had also been mentioned that print would be usable in later specs so I figured I’d just add it now. ## Failing Test CasesThe fail cases all test specific cases of failure. This is partially because it is more informative and partially because until recently there parser halted at any error. The first test case tests correct matching of braces. There are 3 open braces and 4 close braces. It will correctly report that it was expecting a brace but didn’t find one at the end. The last test case catches the opposite of this error by having 3 open 2 closed. The second test case tests the requirement of statement list for it to be surrounded in braces by not including any braces in a two line program. While it correctly lexes it does not parse at there is more than just one statement. One thing to point out is that it correctly lexes a capital letter as an id. This is the only test in which that case exists.The third test case is one of the rare examples of a lex error. In this implementation character lists are tested at lex time and without a close “ it exits.The fourth test case tests matching of parentheses in similar fashion to the first test. The parser finds 3 open parentheses and 2 closed ones and fails.  The fifth and sixth test cases both check to ensure the existence of a digit or an id after an op. Both fail correctly.